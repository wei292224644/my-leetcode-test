# 排序

## 冒泡排序

冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复进行直到没有再需要交换，也就是说该数列已经排序完成。

空间复杂度: `O(1)`
时间复杂度: `O(n^2)`

```javascript
function bubbleSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    //这里的 n-1 是因为最后一个元素在前面的循环中已经排好序了
    for (let j = 0; j < n - 1 - i; j++) {
      // 每次循环到 n-1-i 是因为每完成一轮排序，最后面的 i 个元素已经是有序的了
      if (arr[j] > arr[j + 1]) {
        // 交换
        swap(arr, j, j + 1);
      }
    }
  }
  return arr;
}
```

## 选择排序

选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。

空间复杂度: `O(1)`
时间复杂度: `O(n^2)`

```javascript
function selectionSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    let minIndex = i; // 假设当前 i 位置的元素是最小的
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j; // 更新最小元素的索引
      }
    }
    if (minIndex !== i) {
      swap(arr, i, minIndex); // 交换
    }
  }
  return arr;
}
```

## 插入排序

插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

空间复杂度: `O(1)`
时间复杂度: `O(n^2)`

```javascript
function insertionSort(arr) {
  let n = arr.length;
  for (let i = 1; i < n; i++) {
    let key = arr[i]; // 当前要插入的元素
    let j = i - 1;
    // 将 key 插入到已排序的子数组 arr[0..i-1] 中
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j]; // 元素后移
      j--;
    }
    arr[j + 1] = key; // 插入 key
  }
  return arr;
}
```

## 归并排序

归并排序是一种分治算法。它将数组分成两半，递归地对每一半进行排序，然后将两个已排序的半数组合并成一个有序数组。

空间复杂度: `O(n)`
时间复杂度: `O(n*logn)`

merge 函数用于合并两个有序子数组：

```javascript
const merge = (arr, left, mid, right) => {
  const helper = [];
  let L = left;
  let R = mid + 1;

  while (L <= mid && R <= right) {
    if (arr[L] <= arr[R]) {
      helper.push(arr[L]);
      L++;
    } else {
      helper.push(arr[R]);
      R++;
    }
  }

  while (L <= mid) {
    helper.push(arr[L]);
    L++;
  }

  while (R <= right) {
    helper.push(arr[R]);
    R++;
  }

  for (let i = 0; i < helper.length; i++) {
    arr[left + i] = helper[i];
  }
};
```

### 递归版：

```javascript
const mergeSort = (arr) => {
  if (arr.length <= 1) {
    return arr;
  }

  const process = (arr, left, right) => {
    if (left >= right) {
      return;
    }

    const mid = left + ((right - left) >> 1);
    process(arr, left, mid);
    process(arr, mid + 1, right);
    merge(arr, left, mid, right);
  };

  process(arr, 0, arr.length - 1);
  return arr;
};
```

### 非递归版：

step 变量控制每次合并的子数组长度，从 1 开始，每次翻倍，直到大于等于数组长度为止。在每一步中，从数组的起始位置开始，依次合并相邻的子数组。left 变量用于标记当前要合并的子数组的起始位置，mid 变量计算出当前子数组的中点，right 变量计算出当前子数组的结束位置。每次合并后，left 移动到下一个子数组的起始位置，直到遍历完整个数组。

```javascript
const mergeSortIterative = (arr) => {
  const n = arr.length;
  let step = 1;
  while (step < n) {
    let left = 0; // 每次从数组的第一个位置开始合并
    while (left < n) {
      const mid = left + step - 1; // 注意 mid 可能越界
      if (mid >= n) {
        break;
      }
      const right = Math.min(mid + step, n - 1); // 注意 right 可能越界
      merge(arr, left, mid, right);
      left = right + 1; // 移动到下一对子数组的起始位置
    }
    step <<= 1; // step *= 2，每次合并的子数组长度翻倍
  }
};
```

## 快速排序

快速排序是一种分治算法。他是通过找到（随机）一个基准值，将数组分成三组：小于基准值的、等于基准值的和大于基准值的。然后递归地对小于和大于基准值的子数组进行排序。

空间复杂度: `O(logn)`（递归栈空间）
时间复杂度: `O(n*logn)`

```javascript
const partition = (arr, l, r) => {
  // 荷兰国旗问题划分函数,返回等于区域的左右边界
  if (l > r) {
    return [-1, -1];
  }
  if (l === r) {
    return [l, r];
  }

  let less = l - 1; // < 区右边界
  let more = r; // > 区左边界
  let index = l;

  while (index < more) {
    if (arr[index] < arr[r]) {
      swap(arr, ++less, index++); // 小于时交换并移动index
    } else if (arr[index] == arr[r]) {
      index++; // 相等时只移动index
    } else {
      swap(arr, --more, index);
    }
  }
  swap(arr, more, r); // 将划分值放到正确位置
  return [less + 1, more];
};

const quickSort = (arr) => {
  if (arr == null || arr.length < 2) {
    return;
  }

  const process = (arr, l, r) => {
    if (l >= r) {
      return;
    }

    swap(arr, r, l + Math.floor(Math.random() * (r - l + 1))); //随机选取一个数作为划分值
    const [less, more] = partition(arr, l, r);
    process(arr, l, less - 1); // 处理小于区域
    process(arr, more + 1, r); // 处理大于区域
  };

  const n = arr.length;
  process(arr, 0, n - 1);
  return arr;
};
```
